"use strict";(self.webpackChunkdocusaurus_osebna=self.webpackChunkdocusaurus_osebna||[]).push([["5524"],{5865:function(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"nepremicnine-net-playwright","metadata":{"permalink":"/blog/nepremicnine-net-playwright","source":"@site/blog/2025-12-26-nepremicnine-playwright.mdx","title":"Obvestila za nepremicnine.net s Playwrightom","description":"Na nepremicnine.net sem posku\u0161al narediti preprost scraper z requests, pa je stran hitro vrnila za\u0161\u010Dito/\u010Dudne HTML-je. Zato sem v projektu nepremicnine.net-notify preklopil na Playwright (Firefox), ki stran nalo\u017Ei kot pravi brskalnik in omogo\u010Da zanesljivo pobiranje novih oglasov.","date":"2025-12-26T00:00:00.000Z","tags":[{"inline":true,"label":"python","permalink":"/blog/tags/python"},{"inline":true,"label":"playwright","permalink":"/blog/tags/playwright"},{"inline":true,"label":"telegram","permalink":"/blog/tags/telegram"},{"inline":true,"label":"gmail","permalink":"/blog/tags/gmail"},{"inline":true,"label":"scraping","permalink":"/blog/tags/scraping"}],"readingTime":2.26,"hasTruncateMarker":false,"authors":[{"name":"Rok Damjani\u0107","title":"IT, sports, nature","url":"https://linkedin.com/in/rok-damjanic","socials":{"linkedin":"https://www.linkedin.com/in/rok-damjanic/","github":"https://github.com/roks531"},"imageURL":"/img/profile_photo.jpg","key":"rok","page":null}],"frontMatter":{"slug":"nepremicnine-net-playwright","title":"Obvestila za nepremicnine.net s Playwrightom","authors":["rok"],"tags":["python","playwright","telegram","gmail","scraping"],"comments":true},"unlisted":false,"nextItem":{"title":"office365 mail in openforis arena","permalink":"/blog/openforis-arena-mail"}},"content":"Na nepremicnine.net sem posku\u0161al narediti preprost scraper z `requests`, pa je stran hitro vrnila za\u0161\u010Dito/\u010Dudne HTML-je. Zato sem v projektu [nepremicnine.net-notify](https://github.com/roks531/nepremicnine.net-notify) preklopil na [Playwright](https://playwright.dev/) (Firefox), ki stran nalo\u017Ei kot pravi brskalnik in omogo\u010Da zanesljivo pobiranje novih oglasov.\\n\\nSkripta po\u017Eene ve\u010D iskalnih URL-jev, zbere povezave, preveri katere so nove glede na CSV, ter po\u0161lje obvestila prek Telegrama ali e\u2011po\u0161te (npr. Gmail). Spodaj je kratek vodi\u010D, povzet po README, kako jo pripraviti in pognati.\\n\\n## Zakaj Playwright namesto `requests`\\n- Stran nalaga vsebino dinami\u010Dno in uporablja za\u0161\u010Dite proti botom; klasi\u010Dni HTTP klici vrnejo prazne ali blokirane odgovore.\\n- Playwright simulira pravi browser (tu Firefox), zato pride \u010Dez za\u0161\u010Dito in po\u010Daka, da se rezultati dejansko prika\u017Eejo.\\n- Dodani so naklju\u010Dni zamiki, timeouti in ponovni poskusi, da scraper ostane stabilen in manj o\u010Diten.\\n\\n## Kaj skripta po\u010Dne\\n- Sprejme ve\u010D `SEARCH_URLS` (npr. razli\u010Dne lokacije ali tipe oglasov).\\n- Vsako stran odpre v Playwrightu, \u010Daka na `networkidle` in pobere povezave oglasov.\\n- Podpira paginacijo (`MAX_PAGES`) in ponovne poskuse na timeout.\\n- Shranjuje vse videne povezave v `links.csv`, da po\u0161ilja samo nove oglase.\\n- Po\u0161ilja obvestila na Telegram in/ali SMTP (Gmail z \u201CApp password\u201D).\\n\\n## Hitri zagon\\n```bash\\ngit clone https://github.com/roks531/nepremicnine.net-notify.git\\ncd nepremicnine.net-notify\\ncp .env.example .env    # izpolni svoje podatke\\n\\n# Odvisnosti\\nuv sync                 # ali: pip install -r requirements.txt\\n\\n# Playwright brskalnik (Firefox)\\nuv run playwright install firefox   # ali: python -m playwright install firefox\\n\\n# Pognaj\\nuv run python nepremicnine_parse.py\\n```\\n\\nMinimalen `.env` primer:\\n```env\\nSEARCH_URLS=https://www.nepremicnine.net/oglasi-prodaja/grosuplje/\\nLINKS_FILE=links.csv\\nMAX_PAGES=5\\nSCRAPE_DELAY_MIN=3\\nSCRAPE_DELAY_MAX=6\\nSCRAPE_TIMEOUT_MS=45000\\nSCRAPE_RETRIES=2\\n\\nTELEGRAM_ENABLED=true\\nTELEGRAM_TOKEN=123456:abc\\nTELEGRAM_CHAT_ID=123456789\\n\\nEMAIL_ENABLED=false # true ali false - jaz uporabljam samo telegram, \\npreverjeno pa deluje tudi z gmailom\\nEMAIL_HOST=smtp.gmail.com\\nEMAIL_PORT=587\\nEMAIL_USERNAME=tvoj.gmail@gmail.com\\nEMAIL_PASSWORD=app-password-iz-google\\nEMAIL_FROM=tvoj.gmail@gmail.com\\nEMAIL_TO=prejemnik1@gmail.com,prejemnik2@gmail.com\\n```\\n\\n## Klju\u010Dne nastavitve\\n- **`SEARCH_URLS`**: URL-ji iskanj, lo\u010Deni z vejico ali novimi vrsticami.\\n- **`MAX_PAGES`**: koliko strani na posamezen URL se pregleda.\\n- **`SCRAPE_DELAY_MIN/MAX`** in **`SCRAPE_RETRIES`**: naklju\u010Dni zamik in \u0161tevilo ponovitev ob timeout-u.\\n- **`LINKS_FILE`**: CSV za sledenje \u017Ee videnim oglasom (pusti v `.gitignore`).\\n- **Telegram**: `TELEGRAM_ENABLED`, `TELEGRAM_TOKEN`, `TELEGRAM_CHAT_ID`.\\n- **E-po\u0161ta**: `EMAIL_ENABLED` + `EMAIL_*`; za Gmail obvezno dvofaktorska prijava in \u201CApp password\u201D.\\n\\n## Samodejno poganjanje\\nZa redna obvestila dodaj cron (primer vsako uro):\\n```cron\\n0 * * * * cd /pot/do/nepremicnine.net-notify && /usr/bin/env uv run python nepremicnine_parse.py >> /var/log/nepremicnine.log 2>&1\\n```\\nNa Windows uporabi Task Scheduler (Start a program \u2192 `uv.exe`/`python.exe` + pot do skripte).\\n\\n## Opombe iz prakse\\n- \u010Ce se kak\u0161na stran vseeno ustavi, pove\u010Daj `SCRAPE_TIMEOUT_MS` ali `SCRAPE_RETRIES`.\\n- Playwright potrebuje Firefox in osnovne knji\u017Enice (na Ubuntu jih dobi\u0161 z `apt-get install libnss3 ...`, kot pi\u0161e v README).\\n- Telegram obvestilo ima HTML povezave in izklop predogledov, da ostane pregledno; e\u2011po\u0161ta uporablja navadno besedilo.\\n\\nS tem nastavi\u0161 nezahteven, a zanesljiv bot, ki mimo za\u0161\u010Dit nepremicnine.net pobere nove oglase in te pingne tam, kjer ti najbolj ustreza."},{"id":"openforis-arena-mail","metadata":{"permalink":"/blog/openforis-arena-mail","source":"@site/blog/2025-04-13-openforis_arena_mail.mdx","title":"office365 mail in openforis arena","description":"Fixing Office365 Mail in OpenForis Arena with STARTTLS","date":"2025-04-13T00:00:00.000Z","tags":[{"inline":true,"label":"openforis","permalink":"/blog/tags/openforis"},{"inline":true,"label":"arena","permalink":"/blog/tags/arena"},{"inline":true,"label":"office365","permalink":"/blog/tags/office-365"}],"readingTime":3.435,"hasTruncateMarker":false,"authors":[{"name":"Rok Damjani\u0107","title":"IT, sports, nature","url":"https://linkedin.com/in/rok-damjanic","socials":{"linkedin":"https://www.linkedin.com/in/rok-damjanic/","github":"https://github.com/roks531"},"imageURL":"/img/profile_photo.jpg","key":"rok","page":null}],"frontMatter":{"slug":"openforis-arena-mail","title":"office365 mail in openforis arena","authors":["rok"],"tags":["openforis","arena","office365"],"image":"/img/blog_img/2025-04-13-openforis-arena.png","comments":true},"unlisted":false,"prevItem":{"title":"Obvestila za nepremicnine.net s Playwrightom","permalink":"/blog/nepremicnine-net-playwright"},"nextItem":{"title":"ldap3 in paperless-ngx","permalink":"/blog/paperless-ngx-ldap"}},"content":"## Fixing Office365 Mail in OpenForis Arena with STARTTLS\\n\\nThe [OpenForis Arena](https://github.com/openforis/arena) platform comes with built-in email support, but the default configuration does **not** correctly support STARTTLS when using Office365 SMTP servers. This causes the entire mailing service to fail \u2014 which means **new users cannot register**, and existing admins are **unable to invite users** to join the system.\\n\\nThis guide explains how to patch the email integration to work with Office365 using NodeMailer, configure the necessary environment variables, and deploy Arena using Docker Compose \u2014 complete with working email functionality and GitHub package authentication for building the image.\\n\\nUsing default mailer.js component produces errors like this below, even if the config is correctly filled out.\\n\\n![Error screenshot 1](/img/blog_img/2025-04-13-openforis-arena-error1.png)\\n\\n![Error screenshot 2](/img/blog_img/2025-04-13-openforis-arena-error2.png)\\n\\n---\\n\\n## Why this matters\\n\\nOffice365 requires STARTTLS on port 587 with the correct authentication and TLS configuration. Arena\'s default mail configuration isn\'t compatible, leading to failed email deliveries or TLS handshake errors.\\n\\nWe\u2019ll fix that by:\\n- Modifying Arena\u2019s `mailer.js` file\\n- Enabling Office365 as a mail provider\\n- Setting up appropriate environment variables\\n- Building and running Arena via Docker\\n\\n---\\n\\n## Step 1: Clone the Arena Repository\\n\\n```bash\\ngit clone https://github.com/openforis/arena.git\\ncd arena\\n```\\n\\n---\\n\\n## Step 2: Patch the Mailer Utility\\n\\nEdit the file `server/utils/mailer.js` and replace its contents with the following:\\n\\n```js title=\\"mailer.js\\"\\nimport * as nodemailer from \'nodemailer\'\\nimport * as ProcessUtils from \'@core/processUtils\'\\nimport * as i18nFactory from \'@core/i18n/i18nFactory\'\\nimport * as Log from \'@server/log/log\'\\n\\nconst logger = Log.getLogger(\'Mailer\')\\n\\nconst emailServices = {\\n  office365: \'office365\',\\n}\\n\\nconst emailService = ProcessUtils.ENV.emailService\\nconst authUser = ProcessUtils.ENV.emailAuthUser\\nconst authPass = ProcessUtils.ENV.emailAuthPassword\\nconst from = ProcessUtils.ENV.adminEmail || authUser\\n\\nlogger.debug(\'Email configuration:\', {\\n  emailService,\\n  authUser: authUser ? \'[set]\' : \'[not set]\',\\n  authPass: authPass ? \'[set]\' : \'[not set]\',\\n  from,\\n})\\n\\nconst transporter = nodemailer.createTransport({\\n  host: \'smtp.office365.com\',\\n  port: 587,\\n  secure: false,\\n  auth: {\\n    user: authUser,\\n    pass: authPass,\\n  },\\n  requireTLS: true,\\n  tls: {\\n    minVersion: \'TLSv1.3\',\\n    ciphers: \'TLS_AES_256_GCM_SHA384\',\\n    rejectUnauthorized: false,\\n  },\\n  debug: true,\\n  logger: true,\\n})\\n\\ntransporter.verify((error, success) => {\\n  if (error) {\\n    logger.error(\'\u274C Transporter verification failed on startup:\', error)\\n  } else {\\n    logger.debug(\'\u2705 Transporter verified on startup\')\\n  }\\n})\\n\\nconst sendEmailMSOffice365 = async ({ to, subject, html, text = null }) => {\\n  try {\\n    await transporter.verify()\\n    logger.debug(\'\u2705 Email transporter connection verified before send\')\\n\\n    const info = await transporter.sendMail({\\n      from,\\n      to,\\n      replyTo: from,\\n      subject,\\n      html,\\n      text,\\n    })\\n\\n    logger.debug(\'\uD83D\uDCE9 Email sent:\', info.messageId)\\n    return info\\n  } catch (error) {\\n    logger.error(\'\u274C Email sending error:\', error)\\n    throw error\\n  }\\n}\\n\\nexport const sendEmail = async ({ to, msgKey, msgParams = {}, i18n: i18nParam = null, lang = \'en\' }) => {\\n  if (!authUser || !authPass) {\\n    const error = new Error(\'Email auth credentials not configured in environment\')\\n    logger.error(error.message)\\n    throw error\\n  }\\n\\n  const i18n = i18nParam ? i18nParam : await i18nFactory.createI18nAsync(lang)\\n\\n  const subject = i18n.t(`${msgKey}.subject`, msgParams)\\n  const html = i18n.t(`${msgKey}.body`, msgParams)\\n\\n  if (emailService === emailServices.office365) {\\n    return await sendEmailMSOffice365({ to, subject, html })\\n  } else {\\n    throw new Error(\'Invalid email service specified: \' + emailService)\\n  }\\n}\\n```\\n\\n---\\n\\n## Step 3: Get Your GitHub NPM Token\\n\\nTo build Arena with Arena\u2019s GitHub Packages, you need a personal access token.\\n\\n### How to get your token:\\n\\n1. Go to [GitHub > Settings > Developer settings > Personal access tokens](https://github.com/settings/tokens)\\n2. Click **\\"Generate new token (classic)\\"**\\n3. Select the following scope:\\n   - `read:packages`\\n4. Generate and copy the token. It will look like:\\n\\n```\\nghp_ze4O1W2hfRTZ878d1Fvnndz4eZUDc\\n```\\n\\n---\\n\\n## Step 4: Configure Environment Variables\\n\\nCreate a `.env` file in the root of the Arena project:\\n\\n```env\\nNPM_TOKEN=ghp_ze4O1W2hfRTZ878d1Fvnndz4eZUDc\\n```\\n\\nThen modify the `arena.env` file for Arena\u2019s runtime environment:\\n\\n```env\\nEMAIL_SERVICE=office365\\nEMAIL_AUTH_USER=your_admin_mail@mail.com (same as in arena.env)\\nEMAIL_AUTH_PASSWORD=your_office365_password\\n```\\n\\n---\\n\\n## Step 5: Build with Docker Compose\\n\\nCreate a `docker-compose.yml` in the root of your project:\\n\\n```yaml\\nservices:\\n  arena:\\n    build:\\n      context: .\\n      dockerfile: Dockerfile\\n      args:\\n        - NPM_TOKEN=${NPM_TOKEN}\\n    container_name: openforis-arena\\n    restart: always\\n    env_file:\\n      - arena.env\\n    network_mode: \\"host\\"\\n```\\n\\nThen run:\\n\\n```bash\\ndocker compose build\\ndocker compose up -d\\n```\\n\\n---\\n\\n## All Set!\\n\\nYou now have a working OpenForis Arena deployment that can send emails through Office365 using STARTTLS \u2014 complete with logs, error handling, and secure configuration.\\n\\nNo more failed handshakes or broken notifications. \uD83C\uDF89\\n\\n---"},{"id":"paperless-ngx-ldap","metadata":{"permalink":"/blog/paperless-ngx-ldap","source":"@site/blog/2024-12-23-paperless-ldap.mdx","title":"ldap3 in paperless-ngx","description":"In this post, I will explain how I integrated LDAP authentication into Paperless-ngx using the ldap3 library. By leveraging LDAP, we can centrally manage user authentication, ensuring secure and streamlined access to Paperless-ngx.","date":"2024-12-23T00:00:00.000Z","tags":[{"inline":true,"label":"paperless-ngx","permalink":"/blog/tags/paperless-ngx"},{"inline":true,"label":"ldap3","permalink":"/blog/tags/ldap-3"}],"readingTime":5.15,"hasTruncateMarker":false,"authors":[{"name":"Rok Damjani\u0107","title":"IT, sports, nature","url":"https://linkedin.com/in/rok-damjanic","socials":{"linkedin":"https://www.linkedin.com/in/rok-damjanic/","github":"https://github.com/roks531"},"imageURL":"/img/profile_photo.jpg","key":"rok","page":null}],"frontMatter":{"slug":"paperless-ngx-ldap","title":"ldap3 in paperless-ngx","authors":["rok"],"tags":["paperless-ngx","ldap3"],"image":"/img/blog_img/2024-12-23-paperles-ngx.png"},"unlisted":false,"prevItem":{"title":"office365 mail in openforis arena","permalink":"/blog/openforis-arena-mail"}},"content":"In this post, I will explain how I integrated LDAP authentication into [Paperless-ngx](https://github.com/paperless-ngx/paperless-ngx) using the `ldap3` library. By leveraging LDAP, we can centrally manage user authentication, ensuring secure and streamlined access to Paperless-ngx.\\n\\n## Custom LDAP Authentication Backend\\n\\nThe first step is creating a custom authentication backend. This backend uses `ldap3` to authenticate users against the LDAP directory. Below is the complete implementation also transfering groups from LDAP.\\n\\n### Key Features of the Backend\\n\\n- **Centralized Authentication**: User credentials are verified against the LDAP server.\\n- **Dynamic User Management**: Users are automatically created or updated in the local Django database upon successful authentication.\\n- **Dynamic Group Management**: Groups are automatically generated from those that the user belongs to.\\n- **Admin**: When a user is in the admin group, he also gets a staff member status.\\n- **Logging**: Authentication attempts are logged for debugging and auditing purposes.\\n\\n### The backend including LDAP groups\\n\\n```python title=\\"ldap_auth_backend.py\\"\\n\\nimport logging\\nfrom django.contrib.auth.models import User, Group\\nfrom django.contrib.auth.backends import BaseBackend\\nfrom ldap3 import Server, Connection, ALL, SUBTREE\\n\\n# LDAP Server Configuration\\nLDAP_SERVER = \\"ldap://example.com:3268\\"\\nLDAP_AUTH_SEARCH_BASE = \\"ou=it,ou=departments,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_USERNAME = \\"cn=ldapadmin,ou=users,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_PASSWORD = \\"pass of ldapadmin\\"\\n\\nlogger = logging.getLogger(__name__)\\n\\nclass LDAPBackend(BaseBackend):\\n    def authenticate(self, request, username=None, password=None, **kwargs):\\n        server = Server(LDAP_SERVER, get_info=ALL)\\n        conn = Connection(server, user=LDAP_AUTH_CONNECTION_USERNAME, password=LDAP_AUTH_CONNECTION_PASSWORD, auto_bind=True)\\n\\n        # Define the LDAP search filter to find the user by sAMAccountName\\n        search_filter = f\\"(sAMAccountName={username})\\"\\n\\n        try:\\n            # Search for the user in LDAP\\n            conn.search(\\n                search_base=LDAP_AUTH_SEARCH_BASE,\\n                search_filter=search_filter,\\n                search_scope=SUBTREE,\\n                attributes=[\'sAMAccountName\', \'mail\', \'givenName\', \'sn\', \'memberOf\']\\n            )\\n\\n            if conn.entries:\\n                # If the user exists, attempt to bind with user\'s credentials to authenticate\\n                user_dn = conn.entries[0].entry_dn\\n                user_conn = Connection(server, user=user_dn, password=password, auto_bind=True)\\n\\n                if user_conn.bind():\\n                    # Extract user details from LDAP entry\\n                    ldap_entry = conn.entries[0]\\n                    first_name = ldap_entry.givenName.value if hasattr(ldap_entry, \'givenName\') else \\"\\"\\n                    last_name = ldap_entry.sn.value if hasattr(ldap_entry, \'sn\') else \\"\\"\\n                    email = ldap_entry.mail.value if hasattr(ldap_entry, \'mail\') else \\"\\"\\n                    groups = ldap_entry.memberOf.values if hasattr(ldap_entry, \'memberOf\') else []\\n\\n                    # Get or create the Django user\\n                    user, created = User.objects.get_or_create(username=username)\\n                    if created:\\n                        user.set_unusable_password()\\n                        user.first_name = first_name\\n                        user.last_name = last_name\\n                        user.email = email\\n\\n                    # Create groups and assign the user to them\\n                    for group_dn in groups:\\n                        group_name = group_dn.split(\',\')[0][3:]  # Extract group name from DN (e.g., \\"CN=admin\\" -> \\"admin\\")\\n                        group, _ = Group.objects.get_or_create(name=group_name)  # Ensure the group exists\\n                        if not user.groups.filter(name=group_name).exists():\\n                            user.groups.add(group)\\n\\n                        # Check if the user is part of the \'admin\' group to set is_staff\\n                        if group_name.lower() == \'admin\':\\n                            user.is_staff = True\\n\\n                    user.save()\\n\\n                    logger.info(f\\"User {username} authenticated and {\'created\' if created else \'updated\'} in Django. Assigned to groups {\', \'.join([g.split(\',\')[0][3:] for g in groups])}.\\")\\n                    return user\\n        except Exception as e:\\n            logger.warning(f\\"LDAP authentication failed for user {username}: {e}\\")\\n            return None\\n\\n    def get_user(self, user_id):\\n        try:\\n            return User.objects.get(pk=user_id)\\n        except User.DoesNotExist:\\n            return None\\n```\\n\\n### Backend without groups\\n\\n<details>\\n\\n<summary>example with just user creation without any groups</summary>\\n\\n ```python title=\\"docker-compose.env\\"\\nimport logging\\nfrom django.contrib.auth.models import User\\nfrom django.contrib.auth.backends import BaseBackend\\nfrom ldap3 import Server, Connection, ALL, SUBTREE\\n\\n# LDAP Server Configuration\\nLDAP_SERVER = \\"ldap://example.com:3268\\"\\nLDAP_AUTH_SEARCH_BASE = \\"ou=it,ou=departments,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_USERNAME = \\"cn=ldapadmin,ou=users,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_PASSWORD = \\"pass of ldapadmin\\"\\n\\nlogger = logging.getLogger(__name__)\\n\\nclass LDAPBackend(BaseBackend):\\n    def authenticate(self, request, username=None, password=None, **kwargs):\\n        server = Server(LDAP_SERVER, get_info=ALL)\\n        conn = Connection(server, user=LDAP_AUTH_CONNECTION_USERNAME, password=LDAP_AUTH_CONNECTION_PASSWORD, auto_bind=True)\\n\\n        # Define the LDAP search filter to find the user by sAMAccountName\\n        search_filter = f\\"(sAMAccountName={username})\\"\\n\\n        try:\\n            # Search for the user in LDAP\\n            conn.search(\\n                search_base=LDAP_AUTH_SEARCH_BASE,\\n                search_filter=search_filter,\\n                search_scope=SUBTREE,\\n                attributes=[\'sAMAccountName\', \'mail\', \'givenName\', \'sn\']\\n            )\\n\\n            if conn.entries:\\n                # If the user exists, attempt to bind with user\'s credentials to authenticate\\n                user_dn = conn.entries[0].entry_dn\\n                user_conn = Connection(server, user=user_dn, password=password, auto_bind=True)\\n\\n                if user_conn.bind():\\n                    # Extract user details from LDAP entry\\n                    ldap_entry = conn.entries[0]\\n                    first_name = ldap_entry.givenName.value if hasattr(ldap_entry, \'givenName\') else \\"\\"\\n                    last_name = ldap_entry.sn.value if hasattr(ldap_entry, \'sn\') else \\"\\"\\n                    email = ldap_entry.mail.value if hasattr(ldap_entry, \'mail\') else \\"\\"\\n\\n                    # Get or create the Django user\\n                    user, created = User.objects.get_or_create(username=username)\\n                    if created:\\n                        user.set_unusable_password()\\n\\n                    # Update user\'s first name, last name, and email\\n                    user.first_name = first_name\\n                    user.last_name = last_name\\n                    user.email = email\\n\\n                    # Explicitly set is_staff to False\\n                    user.is_staff = False\\n                    user.save()\\n\\n                    logger.info(f\\"User {username} authenticated and {\'created\' if created else \'updated\'} in Django with name \'{first_name} {last_name}\' and email \'{email}\'.\\")\\n                    return user\\n        except Exception as e:\\n            logger.warning(f\\"LDAP authentication failed for user {username}: {e}\\")\\n            return None\\n\\n    def get_user(self, user_id):\\n        try:\\n            return User.objects.get(pk=user_id)\\n        except User.DoesNotExist:\\n            return None\\n\\n```\\n</details>\\n\\n## Adding LDAP Support to Paperless-ngx\\n\\nTo integrate this backend into Paperless-ngx, I created a custom Docker image and updated the necessary configuration files.\\n\\n### Custom Docker Image\\n\\nI extended the official Paperless-ngx Docker image to include the `ldap3` library and the custom authentication backend. Here\'s the `Dockerfile`:\\n\\n```dockerfile\\n# Start from the official paperless-ngx image\\nFROM ghcr.io/paperless-ngx/paperless-ngx:latest\\n\\n# Install LDAP library\\nRUN pip install ldap3\\n\\n# Copy the custom LDAP backend code\\nCOPY ldap_auth_backend.py /usr/src/paperless/src/paperless/ldap_auth_backend.py\\n\\n# Update settings.py to include the LDAP backend using a sed command\\nRUN sed -i \\"/^AUTHENTICATION_BACKENDS = /a \'paperless.ldap_auth_backend.LDAPBackend\',\\" /usr/src/paperless/src/paperless/settings.py\\n```\\n\\n### Build and Run the Docker Image\\n\\n\\n\\n\\nUse the following commands to build and run the custom Docker image:\\n\\n```bash\\n# Build the Docker image\\ndocker build -t paperless-ngx-ldap .\\n\\n# Run the Docker container\\ndocker run -d \\\\\\n  --name paperless-ngx-ldap \\\\\\n  -e PAPERLESS_DBHOST=your_db_host \\\\\\n  -e PAPERLESS_DBPASS=your_db_password \\\\\\n  -e PAPERLESS_TIMEZONE=your_timezone \\\\\\n  -p 8000:8000 \\\\\\n  paperless-ngx-ldap\\n```\\n\\n#### Docker compose example with existing postgresql\\n\\n<details>\\n  <summary>docker-compose.yml example</summary>\\n\\n  This is an example docker compose file\\n\\n  ```yaml title=\\"docker-compose.yml\\"\\n  services:\\n  broker:\\n    image: docker.io/library/redis:7\\n    restart: unless-stopped\\n    volumes:\\n      - redisdata:/data\\n\\n  webserver:\\n    build: .\\n    restart: unless-stopped\\n    depends_on:\\n      - broker\\n      - gotenberg\\n      - tika\\n    ports:\\n      - \\"8000:8000\\"\\n    volumes:\\n      - /home/user/docker-compose/paperless-ngx/data/:/usr/src/paperless/data\\n      - /home/user/docker-compose/paperless-ngx/media/:/usr/src/paperless/media\\n      - /home/user/docker-compose/paperless-ngx/export:/usr/src/paperless/export\\n      - /home/user/docker-compose/paperless-ngx/consume/:/usr/src/paperless/consume\\n\\n    env_file: docker-compose.env\\n    environment:\\n      PAPERLESS_REDIS: redis://broker:6379\\n      PAPERLESS_TIKA_ENABLED: 1\\n      PAPERLESS_TIKA_GOTENBERG_ENDPOINT: http://gotenberg:3000\\n      PAPERLESS_TIKA_ENDPOINT: http://tika:9998\\n      PAPERLESS_LDAP_PIP_INSTALL: \\"true\\"\\n\\n  gotenberg:\\n    image: docker.io/gotenberg/gotenberg:7.8\\n    restart: unless-stopped\\n\\n    command:\\n      - \\"gotenberg\\"\\n      - \\"--chromium-disable-javascript=true\\"\\n      - \\"--chromium-allow-list=file:///tmp/.*\\"\\n\\n  tika:\\n    image: ghcr.io/paperless-ngx/tika:latest\\n    restart: unless-stopped\\n\\n  volumes:\\n    data:\\n    media:\\n    redisdata:\\n\\n  ```\\n</details>\\n\\n\\n<details>\\n\\n<summary>environment example</summary>\\n\\n ```\xecni title=\\"docker-compose.env\\"\\n    PAPERLESS_TIME_ZONE=Europe/Ljubljana\\n    PAPERLESS_OCR_LANGUAGE=eng+slv+deu\\n    PAPERLESS_SECRET_KEY=OO5345345349urerexuRj1nkKoUmKzJJcq2vBik4Cwre0luVS9iapnLP5\\n    PAPERLESS_OCR_LANGUAGES=eng slv deu\\n    PAPERLESS_DBENGINE=postgresql\\n    PAPERLESS_DBHOST=192.168.1.2\\n    PAPERLESS_DBPORT=5432\\n    PAPERLESS_DBUSER: paperless\\n    PAPERLESS_DBPASS: strongpass\\n    PAPERLESS_URL=https://paperless.example.com\\n    PAPERLESS_CSRF_TRUSTED_ORIGINS=https://paperless.example.com,https://example.com\\n    PAPERLESS_ALLOWED_HOSTS=paperless.paperless.example.com,192.168.1.4,example.com\\n    PAPERLESS_CORS_ALLOWED_HOSTS=https://paperless.example.com,https://example.com # can be set using PAPERLESS_URL\\n```\\n</details>\\n\\n\\n\\n\\n## Final Thoughts\\n\\nBy integrating LDAP authentication into Paperless-ngx, I was able to streamline user management and centralize authentication using our existing LDAP infrastructure. The flexibility of Paperless-ngx and the power of `ldap3` made this integration straightforward and effective. I hope this guide helps others looking to implement similar functionality. There are also others who managed to create usefull integrations on (didn\'t work for me though): https://github.com/paperless-ngx/paperless-ngx/discussions/3228."}]}}')}}]);