"use strict";(self.webpackChunkdocusaurus_osebna=self.webpackChunkdocusaurus_osebna||[]).push([["5524"],{5865:function(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"openforis-arena-mail","metadata":{"permalink":"/blog/openforis-arena-mail","source":"@site/blog/2025-04-13-openforis_arena_mail.mdx","title":"office365 mail in openforis arena","description":"Fixing Office365 Mail in OpenForis Arena with STARTTLS","date":"2025-04-13T00:00:00.000Z","tags":[{"inline":true,"label":"openforis","permalink":"/blog/tags/openforis"},{"inline":true,"label":"arena","permalink":"/blog/tags/arena"},{"inline":true,"label":"office365","permalink":"/blog/tags/office-365"}],"readingTime":3.435,"hasTruncateMarker":false,"authors":[{"name":"Rok Damjani\u0107","title":"IT, sports, nature","url":"https://linkedin.com/in/rok-damjanic","socials":{"linkedin":"https://www.linkedin.com/in/rok-damjanic/","github":"https://github.com/roks531"},"imageURL":"/img/profile_photo.jpg","key":"rok","page":null}],"frontMatter":{"slug":"openforis-arena-mail","title":"office365 mail in openforis arena","authors":["rok"],"tags":["openforis","arena","office365"],"image":"/img/blog_img/2025-04-13-openforis-arena.png","comments":true},"unlisted":false,"nextItem":{"title":"ldap3 in paperless-ngx","permalink":"/blog/paperless-ngx-ldap"}},"content":"## Fixing Office365 Mail in OpenForis Arena with STARTTLS\\n\\nThe [OpenForis Arena](https://github.com/openforis/arena) platform comes with built-in email support, but the default configuration does **not** correctly support STARTTLS when using Office365 SMTP servers. This causes the entire mailing service to fail \u2014 which means **new users cannot register**, and existing admins are **unable to invite users** to join the system.\\n\\nThis guide explains how to patch the email integration to work with Office365 using NodeMailer, configure the necessary environment variables, and deploy Arena using Docker Compose \u2014 complete with working email functionality and GitHub package authentication for building the image.\\n\\nUsing default mailer.js component produces errors like this below, even if the config is correctly filled out.\\n\\n![Error screenshot 1](/img/blog_img/2025-04-13-openforis-arena-error1.png)\\n\\n![Error screenshot 2](/img/blog_img/2025-04-13-openforis-arena-error2.png)\\n\\n---\\n\\n## Why this matters\\n\\nOffice365 requires STARTTLS on port 587 with the correct authentication and TLS configuration. Arena\'s default mail configuration isn\'t compatible, leading to failed email deliveries or TLS handshake errors.\\n\\nWe\u2019ll fix that by:\\n- Modifying Arena\u2019s `mailer.js` file\\n- Enabling Office365 as a mail provider\\n- Setting up appropriate environment variables\\n- Building and running Arena via Docker\\n\\n---\\n\\n## Step 1: Clone the Arena Repository\\n\\n```bash\\ngit clone https://github.com/openforis/arena.git\\ncd arena\\n```\\n\\n---\\n\\n## Step 2: Patch the Mailer Utility\\n\\nEdit the file `server/utils/mailer.js` and replace its contents with the following:\\n\\n```js title=\\"mailer.js\\"\\nimport * as nodemailer from \'nodemailer\'\\nimport * as ProcessUtils from \'@core/processUtils\'\\nimport * as i18nFactory from \'@core/i18n/i18nFactory\'\\nimport * as Log from \'@server/log/log\'\\n\\nconst logger = Log.getLogger(\'Mailer\')\\n\\nconst emailServices = {\\n  office365: \'office365\',\\n}\\n\\nconst emailService = ProcessUtils.ENV.emailService\\nconst authUser = ProcessUtils.ENV.emailAuthUser\\nconst authPass = ProcessUtils.ENV.emailAuthPassword\\nconst from = ProcessUtils.ENV.adminEmail || authUser\\n\\nlogger.debug(\'Email configuration:\', {\\n  emailService,\\n  authUser: authUser ? \'[set]\' : \'[not set]\',\\n  authPass: authPass ? \'[set]\' : \'[not set]\',\\n  from,\\n})\\n\\nconst transporter = nodemailer.createTransport({\\n  host: \'smtp.office365.com\',\\n  port: 587,\\n  secure: false,\\n  auth: {\\n    user: authUser,\\n    pass: authPass,\\n  },\\n  requireTLS: true,\\n  tls: {\\n    minVersion: \'TLSv1.3\',\\n    ciphers: \'TLS_AES_256_GCM_SHA384\',\\n    rejectUnauthorized: false,\\n  },\\n  debug: true,\\n  logger: true,\\n})\\n\\ntransporter.verify((error, success) => {\\n  if (error) {\\n    logger.error(\'\u274C Transporter verification failed on startup:\', error)\\n  } else {\\n    logger.debug(\'\u2705 Transporter verified on startup\')\\n  }\\n})\\n\\nconst sendEmailMSOffice365 = async ({ to, subject, html, text = null }) => {\\n  try {\\n    await transporter.verify()\\n    logger.debug(\'\u2705 Email transporter connection verified before send\')\\n\\n    const info = await transporter.sendMail({\\n      from,\\n      to,\\n      replyTo: from,\\n      subject,\\n      html,\\n      text,\\n    })\\n\\n    logger.debug(\'\uD83D\uDCE9 Email sent:\', info.messageId)\\n    return info\\n  } catch (error) {\\n    logger.error(\'\u274C Email sending error:\', error)\\n    throw error\\n  }\\n}\\n\\nexport const sendEmail = async ({ to, msgKey, msgParams = {}, i18n: i18nParam = null, lang = \'en\' }) => {\\n  if (!authUser || !authPass) {\\n    const error = new Error(\'Email auth credentials not configured in environment\')\\n    logger.error(error.message)\\n    throw error\\n  }\\n\\n  const i18n = i18nParam ? i18nParam : await i18nFactory.createI18nAsync(lang)\\n\\n  const subject = i18n.t(`${msgKey}.subject`, msgParams)\\n  const html = i18n.t(`${msgKey}.body`, msgParams)\\n\\n  if (emailService === emailServices.office365) {\\n    return await sendEmailMSOffice365({ to, subject, html })\\n  } else {\\n    throw new Error(\'Invalid email service specified: \' + emailService)\\n  }\\n}\\n```\\n\\n---\\n\\n## Step 3: Get Your GitHub NPM Token\\n\\nTo build Arena with Arena\u2019s GitHub Packages, you need a personal access token.\\n\\n### How to get your token:\\n\\n1. Go to [GitHub > Settings > Developer settings > Personal access tokens](https://github.com/settings/tokens)\\n2. Click **\\"Generate new token (classic)\\"**\\n3. Select the following scope:\\n   - `read:packages`\\n4. Generate and copy the token. It will look like:\\n\\n```\\nghp_ze4O1W2hfRTZ878d1Fvnndz4eZUDc\\n```\\n\\n---\\n\\n## Step 4: Configure Environment Variables\\n\\nCreate a `.env` file in the root of the Arena project:\\n\\n```env\\nNPM_TOKEN=ghp_ze4O1W2hfRTZ878d1Fvnndz4eZUDc\\n```\\n\\nThen modify the `arena.env` file for Arena\u2019s runtime environment:\\n\\n```env\\nEMAIL_SERVICE=office365\\nEMAIL_AUTH_USER=your_admin_mail@mail.com (same as in arena.env)\\nEMAIL_AUTH_PASSWORD=your_office365_password\\n```\\n\\n---\\n\\n## Step 5: Build with Docker Compose\\n\\nCreate a `docker-compose.yml` in the root of your project:\\n\\n```yaml\\nservices:\\n  arena:\\n    build:\\n      context: .\\n      dockerfile: Dockerfile\\n      args:\\n        - NPM_TOKEN=${NPM_TOKEN}\\n    container_name: openforis-arena\\n    restart: always\\n    env_file:\\n      - arena.env\\n    network_mode: \\"host\\"\\n```\\n\\nThen run:\\n\\n```bash\\ndocker compose build\\ndocker compose up -d\\n```\\n\\n---\\n\\n## All Set!\\n\\nYou now have a working OpenForis Arena deployment that can send emails through Office365 using STARTTLS \u2014 complete with logs, error handling, and secure configuration.\\n\\nNo more failed handshakes or broken notifications. \uD83C\uDF89\\n\\n---"},{"id":"paperless-ngx-ldap","metadata":{"permalink":"/blog/paperless-ngx-ldap","source":"@site/blog/2024-12-23-paperless-ldap.mdx","title":"ldap3 in paperless-ngx","description":"In this post, I will explain how I integrated LDAP authentication into Paperless-ngx using the ldap3 library. By leveraging LDAP, we can centrally manage user authentication, ensuring secure and streamlined access to Paperless-ngx.","date":"2024-12-23T00:00:00.000Z","tags":[{"inline":true,"label":"paperless-ngx","permalink":"/blog/tags/paperless-ngx"},{"inline":true,"label":"ldap3","permalink":"/blog/tags/ldap-3"}],"readingTime":5.15,"hasTruncateMarker":false,"authors":[{"name":"Rok Damjani\u0107","title":"IT, sports, nature","url":"https://linkedin.com/in/rok-damjanic","socials":{"linkedin":"https://www.linkedin.com/in/rok-damjanic/","github":"https://github.com/roks531"},"imageURL":"/img/profile_photo.jpg","key":"rok","page":null}],"frontMatter":{"slug":"paperless-ngx-ldap","title":"ldap3 in paperless-ngx","authors":["rok"],"tags":["paperless-ngx","ldap3"],"image":"/img/blog_img/2024-12-23-paperles-ngx.png"},"unlisted":false,"prevItem":{"title":"office365 mail in openforis arena","permalink":"/blog/openforis-arena-mail"}},"content":"In this post, I will explain how I integrated LDAP authentication into [Paperless-ngx](https://github.com/paperless-ngx/paperless-ngx) using the `ldap3` library. By leveraging LDAP, we can centrally manage user authentication, ensuring secure and streamlined access to Paperless-ngx.\\n\\n## Custom LDAP Authentication Backend\\n\\nThe first step is creating a custom authentication backend. This backend uses `ldap3` to authenticate users against the LDAP directory. Below is the complete implementation also transfering groups from LDAP.\\n\\n### Key Features of the Backend\\n\\n- **Centralized Authentication**: User credentials are verified against the LDAP server.\\n- **Dynamic User Management**: Users are automatically created or updated in the local Django database upon successful authentication.\\n- **Dynamic Group Management**: Groups are automatically generated from those that the user belongs to.\\n- **Admin**: When a user is in the admin group, he also gets a staff member status.\\n- **Logging**: Authentication attempts are logged for debugging and auditing purposes.\\n\\n### The backend including LDAP groups\\n\\n```python title=\\"ldap_auth_backend.py\\"\\n\\nimport logging\\nfrom django.contrib.auth.models import User, Group\\nfrom django.contrib.auth.backends import BaseBackend\\nfrom ldap3 import Server, Connection, ALL, SUBTREE\\n\\n# LDAP Server Configuration\\nLDAP_SERVER = \\"ldap://example.com:3268\\"\\nLDAP_AUTH_SEARCH_BASE = \\"ou=it,ou=departments,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_USERNAME = \\"cn=ldapadmin,ou=users,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_PASSWORD = \\"pass of ldapadmin\\"\\n\\nlogger = logging.getLogger(__name__)\\n\\nclass LDAPBackend(BaseBackend):\\n    def authenticate(self, request, username=None, password=None, **kwargs):\\n        server = Server(LDAP_SERVER, get_info=ALL)\\n        conn = Connection(server, user=LDAP_AUTH_CONNECTION_USERNAME, password=LDAP_AUTH_CONNECTION_PASSWORD, auto_bind=True)\\n\\n        # Define the LDAP search filter to find the user by sAMAccountName\\n        search_filter = f\\"(sAMAccountName={username})\\"\\n\\n        try:\\n            # Search for the user in LDAP\\n            conn.search(\\n                search_base=LDAP_AUTH_SEARCH_BASE,\\n                search_filter=search_filter,\\n                search_scope=SUBTREE,\\n                attributes=[\'sAMAccountName\', \'mail\', \'givenName\', \'sn\', \'memberOf\']\\n            )\\n\\n            if conn.entries:\\n                # If the user exists, attempt to bind with user\'s credentials to authenticate\\n                user_dn = conn.entries[0].entry_dn\\n                user_conn = Connection(server, user=user_dn, password=password, auto_bind=True)\\n\\n                if user_conn.bind():\\n                    # Extract user details from LDAP entry\\n                    ldap_entry = conn.entries[0]\\n                    first_name = ldap_entry.givenName.value if hasattr(ldap_entry, \'givenName\') else \\"\\"\\n                    last_name = ldap_entry.sn.value if hasattr(ldap_entry, \'sn\') else \\"\\"\\n                    email = ldap_entry.mail.value if hasattr(ldap_entry, \'mail\') else \\"\\"\\n                    groups = ldap_entry.memberOf.values if hasattr(ldap_entry, \'memberOf\') else []\\n\\n                    # Get or create the Django user\\n                    user, created = User.objects.get_or_create(username=username)\\n                    if created:\\n                        user.set_unusable_password()\\n                        user.first_name = first_name\\n                        user.last_name = last_name\\n                        user.email = email\\n\\n                    # Create groups and assign the user to them\\n                    for group_dn in groups:\\n                        group_name = group_dn.split(\',\')[0][3:]  # Extract group name from DN (e.g., \\"CN=admin\\" -> \\"admin\\")\\n                        group, _ = Group.objects.get_or_create(name=group_name)  # Ensure the group exists\\n                        if not user.groups.filter(name=group_name).exists():\\n                            user.groups.add(group)\\n\\n                        # Check if the user is part of the \'admin\' group to set is_staff\\n                        if group_name.lower() == \'admin\':\\n                            user.is_staff = True\\n\\n                    user.save()\\n\\n                    logger.info(f\\"User {username} authenticated and {\'created\' if created else \'updated\'} in Django. Assigned to groups {\', \'.join([g.split(\',\')[0][3:] for g in groups])}.\\")\\n                    return user\\n        except Exception as e:\\n            logger.warning(f\\"LDAP authentication failed for user {username}: {e}\\")\\n            return None\\n\\n    def get_user(self, user_id):\\n        try:\\n            return User.objects.get(pk=user_id)\\n        except User.DoesNotExist:\\n            return None\\n```\\n\\n### Backend without groups\\n\\n<details>\\n\\n<summary>example with just user creation without any groups</summary>\\n\\n ```python title=\\"docker-compose.env\\"\\nimport logging\\nfrom django.contrib.auth.models import User\\nfrom django.contrib.auth.backends import BaseBackend\\nfrom ldap3 import Server, Connection, ALL, SUBTREE\\n\\n# LDAP Server Configuration\\nLDAP_SERVER = \\"ldap://example.com:3268\\"\\nLDAP_AUTH_SEARCH_BASE = \\"ou=it,ou=departments,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_USERNAME = \\"cn=ldapadmin,ou=users,dc=example,dc=com\\"\\nLDAP_AUTH_CONNECTION_PASSWORD = \\"pass of ldapadmin\\"\\n\\nlogger = logging.getLogger(__name__)\\n\\nclass LDAPBackend(BaseBackend):\\n    def authenticate(self, request, username=None, password=None, **kwargs):\\n        server = Server(LDAP_SERVER, get_info=ALL)\\n        conn = Connection(server, user=LDAP_AUTH_CONNECTION_USERNAME, password=LDAP_AUTH_CONNECTION_PASSWORD, auto_bind=True)\\n\\n        # Define the LDAP search filter to find the user by sAMAccountName\\n        search_filter = f\\"(sAMAccountName={username})\\"\\n\\n        try:\\n            # Search for the user in LDAP\\n            conn.search(\\n                search_base=LDAP_AUTH_SEARCH_BASE,\\n                search_filter=search_filter,\\n                search_scope=SUBTREE,\\n                attributes=[\'sAMAccountName\', \'mail\', \'givenName\', \'sn\']\\n            )\\n\\n            if conn.entries:\\n                # If the user exists, attempt to bind with user\'s credentials to authenticate\\n                user_dn = conn.entries[0].entry_dn\\n                user_conn = Connection(server, user=user_dn, password=password, auto_bind=True)\\n\\n                if user_conn.bind():\\n                    # Extract user details from LDAP entry\\n                    ldap_entry = conn.entries[0]\\n                    first_name = ldap_entry.givenName.value if hasattr(ldap_entry, \'givenName\') else \\"\\"\\n                    last_name = ldap_entry.sn.value if hasattr(ldap_entry, \'sn\') else \\"\\"\\n                    email = ldap_entry.mail.value if hasattr(ldap_entry, \'mail\') else \\"\\"\\n\\n                    # Get or create the Django user\\n                    user, created = User.objects.get_or_create(username=username)\\n                    if created:\\n                        user.set_unusable_password()\\n\\n                    # Update user\'s first name, last name, and email\\n                    user.first_name = first_name\\n                    user.last_name = last_name\\n                    user.email = email\\n\\n                    # Explicitly set is_staff to False\\n                    user.is_staff = False\\n                    user.save()\\n\\n                    logger.info(f\\"User {username} authenticated and {\'created\' if created else \'updated\'} in Django with name \'{first_name} {last_name}\' and email \'{email}\'.\\")\\n                    return user\\n        except Exception as e:\\n            logger.warning(f\\"LDAP authentication failed for user {username}: {e}\\")\\n            return None\\n\\n    def get_user(self, user_id):\\n        try:\\n            return User.objects.get(pk=user_id)\\n        except User.DoesNotExist:\\n            return None\\n\\n```\\n</details>\\n\\n## Adding LDAP Support to Paperless-ngx\\n\\nTo integrate this backend into Paperless-ngx, I created a custom Docker image and updated the necessary configuration files.\\n\\n### Custom Docker Image\\n\\nI extended the official Paperless-ngx Docker image to include the `ldap3` library and the custom authentication backend. Here\'s the `Dockerfile`:\\n\\n```dockerfile\\n# Start from the official paperless-ngx image\\nFROM ghcr.io/paperless-ngx/paperless-ngx:latest\\n\\n# Install LDAP library\\nRUN pip install ldap3\\n\\n# Copy the custom LDAP backend code\\nCOPY ldap_auth_backend.py /usr/src/paperless/src/paperless/ldap_auth_backend.py\\n\\n# Update settings.py to include the LDAP backend using a sed command\\nRUN sed -i \\"/^AUTHENTICATION_BACKENDS = /a \'paperless.ldap_auth_backend.LDAPBackend\',\\" /usr/src/paperless/src/paperless/settings.py\\n```\\n\\n### Build and Run the Docker Image\\n\\n\\n\\n\\nUse the following commands to build and run the custom Docker image:\\n\\n```bash\\n# Build the Docker image\\ndocker build -t paperless-ngx-ldap .\\n\\n# Run the Docker container\\ndocker run -d \\\\\\n  --name paperless-ngx-ldap \\\\\\n  -e PAPERLESS_DBHOST=your_db_host \\\\\\n  -e PAPERLESS_DBPASS=your_db_password \\\\\\n  -e PAPERLESS_TIMEZONE=your_timezone \\\\\\n  -p 8000:8000 \\\\\\n  paperless-ngx-ldap\\n```\\n\\n#### Docker compose example with existing postgresql\\n\\n<details>\\n  <summary>docker-compose.yml example</summary>\\n\\n  This is an example docker compose file\\n\\n  ```yaml title=\\"docker-compose.yml\\"\\n  services:\\n  broker:\\n    image: docker.io/library/redis:7\\n    restart: unless-stopped\\n    volumes:\\n      - redisdata:/data\\n\\n  webserver:\\n    build: .\\n    restart: unless-stopped\\n    depends_on:\\n      - broker\\n      - gotenberg\\n      - tika\\n    ports:\\n      - \\"8000:8000\\"\\n    volumes:\\n      - /home/user/docker-compose/paperless-ngx/data/:/usr/src/paperless/data\\n      - /home/user/docker-compose/paperless-ngx/media/:/usr/src/paperless/media\\n      - /home/user/docker-compose/paperless-ngx/export:/usr/src/paperless/export\\n      - /home/user/docker-compose/paperless-ngx/consume/:/usr/src/paperless/consume\\n\\n    env_file: docker-compose.env\\n    environment:\\n      PAPERLESS_REDIS: redis://broker:6379\\n      PAPERLESS_TIKA_ENABLED: 1\\n      PAPERLESS_TIKA_GOTENBERG_ENDPOINT: http://gotenberg:3000\\n      PAPERLESS_TIKA_ENDPOINT: http://tika:9998\\n      PAPERLESS_LDAP_PIP_INSTALL: \\"true\\"\\n\\n  gotenberg:\\n    image: docker.io/gotenberg/gotenberg:7.8\\n    restart: unless-stopped\\n\\n    command:\\n      - \\"gotenberg\\"\\n      - \\"--chromium-disable-javascript=true\\"\\n      - \\"--chromium-allow-list=file:///tmp/.*\\"\\n\\n  tika:\\n    image: ghcr.io/paperless-ngx/tika:latest\\n    restart: unless-stopped\\n\\n  volumes:\\n    data:\\n    media:\\n    redisdata:\\n\\n  ```\\n</details>\\n\\n\\n<details>\\n\\n<summary>environment example</summary>\\n\\n ```\xecni title=\\"docker-compose.env\\"\\n    PAPERLESS_TIME_ZONE=Europe/Ljubljana\\n    PAPERLESS_OCR_LANGUAGE=eng+slv+deu\\n    PAPERLESS_SECRET_KEY=OO5345345349urerexuRj1nkKoUmKzJJcq2vBik4Cwre0luVS9iapnLP5\\n    PAPERLESS_OCR_LANGUAGES=eng slv deu\\n    PAPERLESS_DBENGINE=postgresql\\n    PAPERLESS_DBHOST=192.168.1.2\\n    PAPERLESS_DBPORT=5432\\n    PAPERLESS_DBUSER: paperless\\n    PAPERLESS_DBPASS: strongpass\\n    PAPERLESS_URL=https://paperless.example.com\\n    PAPERLESS_CSRF_TRUSTED_ORIGINS=https://paperless.example.com,https://example.com\\n    PAPERLESS_ALLOWED_HOSTS=paperless.paperless.example.com,192.168.1.4,example.com\\n    PAPERLESS_CORS_ALLOWED_HOSTS=https://paperless.example.com,https://example.com # can be set using PAPERLESS_URL\\n```\\n</details>\\n\\n\\n\\n\\n## Final Thoughts\\n\\nBy integrating LDAP authentication into Paperless-ngx, I was able to streamline user management and centralize authentication using our existing LDAP infrastructure. The flexibility of Paperless-ngx and the power of `ldap3` made this integration straightforward and effective. I hope this guide helps others looking to implement similar functionality. There are also others who managed to create usefull integrations on (didn\'t work for me though): https://github.com/paperless-ngx/paperless-ngx/discussions/3228."}]}}')}}]);